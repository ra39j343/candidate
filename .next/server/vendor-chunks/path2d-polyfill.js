"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/path2d-polyfill";
exports.ids = ["vendor-chunks/path2d-polyfill"];
exports.modules = {

/***/ "(rsc)/./node_modules/path2d-polyfill/dist/path2d-node.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/path2d-polyfill/dist/path2d-node.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\n\nvar ARG_LENGTH = {\n    a: 7,\n    c: 6,\n    h: 1,\n    l: 2,\n    m: 2,\n    q: 4,\n    s: 4,\n    t: 2,\n    v: 1,\n    z: 0\n};\nvar SEGMENT_PATTERN = /([astvzqmhlc])([^astvzqmhlc]*)/gi;\nvar NUMBER = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/gi;\nfunction parseValues(args) {\n    var numbers = args.match(NUMBER);\n    return numbers ? numbers.map(Number) : [];\n}\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * https://www.w3.org/TR/SVG/paths.html#PathDataGeneralInformation\n * @ignore\n *\n * @param {string} path\n * @returns {array}\n */\nfunction parsePath(path) {\n    var data = [];\n    var p = String(path).trim();\n    // A path data segment (if there is one) must begin with a \"moveto\" command\n    if (p[0] !== \"M\" && p[0] !== \"m\") {\n        return data;\n    }\n    p.replace(SEGMENT_PATTERN, function (_, command, args) {\n        var theArgs = parseValues(args);\n        var type = command.toLowerCase();\n        var theCommand = command;\n        // overloaded moveTo\n        if (type === \"m\" && theArgs.length > 2) {\n            data.push(__spreadArray([theCommand], theArgs.splice(0, 2), true));\n            type = \"l\";\n            theCommand = theCommand === \"m\" ? \"l\" : \"L\";\n        }\n        // Ignore invalid commands\n        if (theArgs.length < ARG_LENGTH[type]) {\n            return \"\";\n        }\n        data.push(__spreadArray([theCommand], theArgs.splice(0, ARG_LENGTH[type]), true));\n        // The command letter can be eliminated on subsequent commands if the\n        // same command is used multiple times in a row (e.g., you can drop the\n        // second \"L\" in \"M 100 200 L 200 100 L -100 -200\" and use\n        // \"M 100 200 L 200 100 -100 -200\" instead).\n        while (theArgs.length >= ARG_LENGTH[type] && theArgs.length && ARG_LENGTH[type]) {\n            data.push(__spreadArray([theCommand], theArgs.splice(0, ARG_LENGTH[type]), true));\n        }\n        return \"\";\n    });\n    return data;\n}\n\nfunction rotatePoint(point, angle) {\n    var nx = point.x * Math.cos(angle) - point.y * Math.sin(angle);\n    var ny = point.y * Math.cos(angle) + point.x * Math.sin(angle);\n    point.x = nx;\n    point.y = ny;\n}\nfunction translatePoint(point, dx, dy) {\n    point.x += dx;\n    point.y += dy;\n}\nfunction scalePoint(point, s) {\n    point.x *= s;\n    point.y *= s;\n}\n/**\n * Implements a browser's Path2D api\n */\nvar Path2D = /** @class */ (function () {\n    function Path2D(path) {\n        var _a;\n        this.commands = [];\n        if (path && path instanceof Path2D) {\n            (_a = this.commands).push.apply(_a, path.commands);\n        }\n        else if (path) {\n            this.commands = parsePath(path);\n        }\n    }\n    Path2D.prototype.addPath = function (path) {\n        var _a;\n        if (path && path instanceof Path2D) {\n            (_a = this.commands).push.apply(_a, path.commands);\n        }\n    };\n    Path2D.prototype.moveTo = function (x, y) {\n        this.commands.push([\"M\", x, y]);\n    };\n    Path2D.prototype.lineTo = function (x, y) {\n        this.commands.push([\"L\", x, y]);\n    };\n    Path2D.prototype.arc = function (x, y, r, start, end, ccw) {\n        this.commands.push([\"AC\", x, y, r, start, end, !!ccw]);\n    };\n    Path2D.prototype.arcTo = function (x1, y1, x2, y2, r) {\n        this.commands.push([\"AT\", x1, y1, x2, y2, r]);\n    };\n    Path2D.prototype.ellipse = function (x, y, rx, ry, angle, start, end, ccw) {\n        this.commands.push([\"E\", x, y, rx, ry, angle, start, end, !!ccw]);\n    };\n    Path2D.prototype.closePath = function () {\n        this.commands.push([\"Z\"]);\n    };\n    Path2D.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n        this.commands.push([\"C\", cp1x, cp1y, cp2x, cp2y, x, y]);\n    };\n    Path2D.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {\n        this.commands.push([\"Q\", cpx, cpy, x, y]);\n    };\n    Path2D.prototype.rect = function (x, y, width, height) {\n        this.commands.push([\"R\", x, y, width, height]);\n    };\n    Path2D.prototype.roundRect = function (x, y, width, height, radii) {\n        if (typeof radii === \"undefined\") {\n            this.commands.push([\"RR\", x, y, width, height, 0]);\n        }\n        else {\n            this.commands.push([\"RR\", x, y, width, height, radii]);\n        }\n    };\n    return Path2D;\n}());\nfunction buildPath(ctx, commands) {\n    var x = 0;\n    var y = 0;\n    var endAngle;\n    var startAngle;\n    var largeArcFlag;\n    var sweepFlag;\n    var endPoint;\n    var midPoint;\n    var angle;\n    var lambda;\n    var t1;\n    var t2;\n    var x1;\n    var y1;\n    var r;\n    var rx;\n    var ry;\n    var w;\n    var h;\n    var pathType;\n    var centerPoint;\n    var ccw;\n    var radii;\n    var cpx = null;\n    var cpy = null;\n    var qcpx = null;\n    var qcpy = null;\n    var startPoint = null;\n    var currentPoint = null;\n    ctx.beginPath();\n    for (var i = 0; i < commands.length; ++i) {\n        pathType = commands[i][0];\n        // Reset control point if command is not cubic\n        if (pathType !== \"S\" && pathType !== \"s\" && pathType !== \"C\" && pathType !== \"c\") {\n            cpx = null;\n            cpy = null;\n        }\n        if (pathType !== \"T\" && pathType !== \"t\" && pathType !== \"Q\" && pathType !== \"q\") {\n            qcpx = null;\n            qcpy = null;\n        }\n        var c = void 0;\n        switch (pathType) {\n            case \"m\":\n            case \"M\":\n                c = commands[i];\n                if (pathType === \"m\") {\n                    x += c[1];\n                    y += c[2];\n                }\n                else {\n                    x = c[1];\n                    y = c[2];\n                }\n                if (pathType === \"M\" || !startPoint) {\n                    startPoint = { x: x, y: y };\n                }\n                ctx.moveTo(x, y);\n                break;\n            case \"l\":\n                c = commands[i];\n                x += c[1];\n                y += c[2];\n                ctx.lineTo(x, y);\n                break;\n            case \"L\":\n                c = commands[i];\n                x = c[1];\n                y = c[2];\n                ctx.lineTo(x, y);\n                break;\n            case \"H\":\n                c = commands[i];\n                x = c[1];\n                ctx.lineTo(x, y);\n                break;\n            case \"h\":\n                c = commands[i];\n                x += c[1];\n                ctx.lineTo(x, y);\n                break;\n            case \"V\":\n                c = commands[i];\n                y = c[1];\n                ctx.lineTo(x, y);\n                break;\n            case \"v\":\n                c = commands[i];\n                y += c[1];\n                ctx.lineTo(x, y);\n                break;\n            case \"a\":\n            case \"A\":\n                c = commands[i];\n                if (currentPoint === null) {\n                    throw new Error(\"This should never happen\");\n                }\n                if (pathType === \"a\") {\n                    x += c[6];\n                    y += c[7];\n                }\n                else {\n                    x = c[6];\n                    y = c[7];\n                }\n                rx = c[1]; // rx\n                ry = c[2]; // ry\n                angle = (c[3] * Math.PI) / 180;\n                largeArcFlag = !!c[4];\n                sweepFlag = !!c[5];\n                endPoint = { x: x, y: y };\n                // https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n                midPoint = {\n                    x: (currentPoint.x - endPoint.x) / 2,\n                    y: (currentPoint.y - endPoint.y) / 2\n                };\n                rotatePoint(midPoint, -angle);\n                // radius correction\n                lambda = (midPoint.x * midPoint.x) / (rx * rx) + (midPoint.y * midPoint.y) / (ry * ry);\n                if (lambda > 1) {\n                    lambda = Math.sqrt(lambda);\n                    rx *= lambda;\n                    ry *= lambda;\n                }\n                centerPoint = {\n                    x: (rx * midPoint.y) / ry,\n                    y: -(ry * midPoint.x) / rx\n                };\n                t1 = rx * rx * ry * ry;\n                t2 = rx * rx * midPoint.y * midPoint.y + ry * ry * midPoint.x * midPoint.x;\n                if (sweepFlag !== largeArcFlag) {\n                    scalePoint(centerPoint, Math.sqrt((t1 - t2) / t2) || 0);\n                }\n                else {\n                    scalePoint(centerPoint, -Math.sqrt((t1 - t2) / t2) || 0);\n                }\n                startAngle = Math.atan2((midPoint.y - centerPoint.y) / ry, (midPoint.x - centerPoint.x) / rx);\n                endAngle = Math.atan2(-(midPoint.y + centerPoint.y) / ry, -(midPoint.x + centerPoint.x) / rx);\n                rotatePoint(centerPoint, angle);\n                translatePoint(centerPoint, (endPoint.x + currentPoint.x) / 2, (endPoint.y + currentPoint.y) / 2);\n                ctx.save();\n                ctx.translate(centerPoint.x, centerPoint.y);\n                ctx.rotate(angle);\n                ctx.scale(rx, ry);\n                ctx.arc(0, 0, 1, startAngle, endAngle, !sweepFlag);\n                ctx.restore();\n                break;\n            case \"C\":\n                c = commands[i];\n                cpx = c[3]; // Last control point\n                cpy = c[4];\n                x = c[5];\n                y = c[6];\n                ctx.bezierCurveTo(c[1], c[2], cpx, cpy, x, y);\n                break;\n            case \"c\":\n                c = commands[i];\n                ctx.bezierCurveTo(c[1] + x, c[2] + y, c[3] + x, c[4] + y, c[5] + x, c[6] + y);\n                cpx = c[3] + x; // Last control point\n                cpy = c[4] + y;\n                x += c[5];\n                y += c[6];\n                break;\n            case \"S\":\n                c = commands[i];\n                if (cpx === null || cpy === null) {\n                    cpx = x;\n                    cpy = y;\n                }\n                ctx.bezierCurveTo(2 * x - cpx, 2 * y - cpy, c[1], c[2], c[3], c[4]);\n                cpx = c[1]; // last control point\n                cpy = c[2];\n                x = c[3];\n                y = c[4];\n                break;\n            case \"s\":\n                c = commands[i];\n                if (cpx === null || cpy === null) {\n                    cpx = x;\n                    cpy = y;\n                }\n                ctx.bezierCurveTo(2 * x - cpx, 2 * y - cpy, c[1] + x, c[2] + y, c[3] + x, c[4] + y);\n                cpx = c[1] + x; // last control point\n                cpy = c[2] + y;\n                x += c[3];\n                y += c[4];\n                break;\n            case \"Q\":\n                c = commands[i];\n                qcpx = c[1]; // last control point\n                qcpy = c[2];\n                x = c[3];\n                y = c[4];\n                ctx.quadraticCurveTo(qcpx, qcpy, x, y);\n                break;\n            case \"q\":\n                c = commands[i];\n                qcpx = c[1] + x; // last control point\n                qcpy = c[2] + y;\n                x += c[3];\n                y += c[4];\n                ctx.quadraticCurveTo(qcpx, qcpy, x, y);\n                break;\n            case \"T\":\n                c = commands[i];\n                if (qcpx === null || qcpy === null) {\n                    qcpx = x;\n                    qcpy = y;\n                }\n                qcpx = 2 * x - qcpx; // last control point\n                qcpy = 2 * y - qcpy;\n                x = c[1];\n                y = c[2];\n                ctx.quadraticCurveTo(qcpx, qcpy, x, y);\n                break;\n            case \"t\":\n                c = commands[i];\n                if (qcpx === null || qcpy === null) {\n                    qcpx = x;\n                    qcpy = y;\n                }\n                qcpx = 2 * x - qcpx; // last control point\n                qcpy = 2 * y - qcpy;\n                x += c[1];\n                y += c[2];\n                ctx.quadraticCurveTo(qcpx, qcpy, x, y);\n                break;\n            case \"z\":\n            case \"Z\":\n                if (startPoint) {\n                    x = startPoint.x;\n                    y = startPoint.y;\n                }\n                startPoint = null;\n                ctx.closePath();\n                break;\n            case \"AC\": // arc\n                c = commands[i];\n                x = c[1];\n                y = c[2];\n                r = c[3];\n                startAngle = c[4];\n                endAngle = c[5];\n                ccw = c[6];\n                ctx.arc(x, y, r, startAngle, endAngle, ccw);\n                break;\n            case \"AT\": // arcTo\n                c = commands[i];\n                x1 = c[1];\n                y1 = c[2];\n                x = c[3];\n                y = c[4];\n                r = c[5];\n                ctx.arcTo(x1, y1, x, y, r);\n                break;\n            case \"E\": // ellipse\n                c = commands[i];\n                x = c[1];\n                y = c[2];\n                rx = c[3];\n                ry = c[4];\n                angle = c[5];\n                startAngle = c[6];\n                endAngle = c[7];\n                ccw = c[8];\n                ctx.save();\n                ctx.translate(x, y);\n                ctx.rotate(angle);\n                ctx.scale(rx, ry);\n                ctx.arc(0, 0, 1, startAngle, endAngle, ccw);\n                ctx.restore();\n                break;\n            case \"R\": // rect\n                c = commands[i];\n                x = c[1];\n                y = c[2];\n                w = c[3];\n                h = c[4];\n                startPoint = { x: x, y: y };\n                ctx.rect(x, y, w, h);\n                break;\n            case \"RR\": // roundedRect\n                c = commands[i];\n                x = c[1];\n                y = c[2];\n                w = c[3];\n                h = c[4];\n                radii = c[5];\n                startPoint = { x: x, y: y };\n                ctx.roundRect(x, y, w, h, radii);\n                break;\n        }\n        if (!currentPoint) {\n            currentPoint = { x: x, y: y };\n        }\n        else {\n            currentPoint.x = x;\n            currentPoint.y = y;\n        }\n    }\n}\n/**\n * Polyfills CanvasRenderingContext2D stroke, fill and isPointInPath so that they support Path2D objects.\n * @param {WindowLike} window - window like object containing a CanvasRenderingContext2D constructor\n */\nfunction polyfillPath2D(window) {\n    if (!window || !window.CanvasRenderingContext2D || window.Path2D)\n        return;\n    var CanvasRenderingContext2D = window.CanvasRenderingContext2D;\n    /* eslint-disable @typescript-eslint/unbound-method */\n    // setting unbound functions here. Make sure this is set in function call later\n    var cFill = CanvasRenderingContext2D.prototype.fill;\n    var cStroke = CanvasRenderingContext2D.prototype.stroke;\n    var cIsPointInPath = CanvasRenderingContext2D.prototype.isPointInPath;\n    /* eslint-enable @typescript-eslint/unbound-method */\n    CanvasRenderingContext2D.prototype.fill = function fill() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args[0] instanceof Path2D) {\n            var path = args[0];\n            var fillRule = args[1] || \"nonzero\";\n            buildPath(this, path.commands);\n            cFill.apply(this, [fillRule]);\n        }\n        else {\n            var fillRule = args[0] || \"nonzero\";\n            return cFill.apply(this, [fillRule]);\n        }\n    };\n    CanvasRenderingContext2D.prototype.stroke = function stroke(path) {\n        if (path) {\n            buildPath(this, path.commands);\n        }\n        cStroke.apply(this);\n    };\n    CanvasRenderingContext2D.prototype.isPointInPath = function isPointInPath() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args[0] instanceof Path2D) {\n            // first argument is a Path2D object\n            var path = args[0];\n            var x = args[1];\n            var y = args[2];\n            var fillRule = args[3] || \"nonzero\";\n            buildPath(this, path.commands);\n            return cIsPointInPath.apply(this, [x, y, fillRule]);\n        }\n        else {\n            return cIsPointInPath.apply(this, args);\n        }\n    };\n    window.Path2D = Path2D;\n}\n\nfunction roundRect(x, y, width, height, radii) {\n    var _this = this;\n    if (radii === void 0) { radii = 0; }\n    if (typeof radii === \"number\") {\n        // eslint-disable-next-line no-param-reassign\n        radii = [radii];\n    }\n    // check for range error\n    if (Array.isArray(radii)) {\n        if (radii.length === 0 || radii.length > 4) {\n            throw new RangeError(\"Failed to execute 'roundRect' on '\".concat(this.constructor.name, \"': \").concat(radii.length, \" radii provided. Between one and four radii are necessary.\"));\n        }\n        radii.forEach(function (v) {\n            if (v < 0) {\n                throw new RangeError(\"Failed to execute 'roundRect' on '\".concat(_this.constructor.name, \"': Radius value \").concat(v, \" is negative.\"));\n            }\n        });\n    }\n    else {\n        return;\n    }\n    if (radii.length === 1 && radii[0] === 0) {\n        return this.rect(x, y, width, height);\n    }\n    // set the corners\n    // tl = top left radius\n    // tr = top right radius\n    // br = bottom right radius\n    // bl = bottom left radius\n    var minRadius = Math.min(width, height) / 2;\n    var tr, br, bl;\n    var tl = (tr = br = bl = Math.min(minRadius, radii[0]));\n    if (radii.length === 2) {\n        tr = bl = Math.min(minRadius, radii[1]);\n    }\n    if (radii.length === 3) {\n        tr = bl = Math.min(minRadius, radii[1]);\n        br = Math.min(minRadius, radii[2]);\n    }\n    if (radii.length === 4) {\n        tr = Math.min(minRadius, radii[1]);\n        br = Math.min(minRadius, radii[2]);\n        bl = Math.min(minRadius, radii[3]);\n    }\n    // begin with closing current path\n    // this.closePath();\n    // let's draw the rounded rectangle\n    this.moveTo(x, y + height - bl);\n    this.arcTo(x, y, x + tl, y, tl);\n    this.arcTo(x + width, y, x + width, y + tr, tr);\n    this.arcTo(x + width, y + height, x + width - br, y + height, br);\n    this.arcTo(x, y + height, x, y + height - bl, bl);\n    // and move to rects control point for further path drawing\n    this.moveTo(x, y);\n}\n/**\n * Polyfills roundRect on CanvasRenderingContext2D and Path2D\n * @param {WindowLike} window - window like object containing both CanvasRenderingContext2D and Path2D constructor\n */\nfunction polyfillRoundRect(window) {\n    if (!window || !window.CanvasRenderingContext2D)\n        return;\n    var CanvasRenderingContext2D = window.CanvasRenderingContext2D, Path2D = window.Path2D;\n    // polyfill unsupported roundRect for e.g. firefox https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/roundRect#browser_compatibility\n    if (CanvasRenderingContext2D && !CanvasRenderingContext2D.prototype.roundRect) {\n        CanvasRenderingContext2D.prototype.roundRect = roundRect;\n    }\n    if (Path2D && !Path2D.prototype.roundRect) {\n        Path2D.prototype.roundRect = roundRect;\n    }\n}\n\nexports.Path2D = Path2D;\nexports.parsePath = parsePath;\nexports.polyfillPath2D = polyfillPath2D;\nexports.polyfillRoundRect = polyfillRoundRect;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGF0aDJkLXBvbHlmaWxsL2Rpc3QvcGF0aDJkLW5vZGUuY2pzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEIseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FuZGlkYXRlLWRhdGEtcHJvdG90eXBlLy4vbm9kZV9tb2R1bGVzL3BhdGgyZC1wb2x5ZmlsbC9kaXN0L3BhdGgyZC1ub2RlLmNqcz8yYTk0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XG5cbnZhciBBUkdfTEVOR1RIID0ge1xuICAgIGE6IDcsXG4gICAgYzogNixcbiAgICBoOiAxLFxuICAgIGw6IDIsXG4gICAgbTogMixcbiAgICBxOiA0LFxuICAgIHM6IDQsXG4gICAgdDogMixcbiAgICB2OiAxLFxuICAgIHo6IDBcbn07XG52YXIgU0VHTUVOVF9QQVRURVJOID0gLyhbYXN0dnpxbWhsY10pKFteYXN0dnpxbWhsY10qKS9naTtcbnZhciBOVU1CRVIgPSAvLT9bMC05XSpcXC4/WzAtOV0rKD86ZVstK10/XFxkKyk/L2dpO1xuZnVuY3Rpb24gcGFyc2VWYWx1ZXMoYXJncykge1xuICAgIHZhciBudW1iZXJzID0gYXJncy5tYXRjaChOVU1CRVIpO1xuICAgIHJldHVybiBudW1iZXJzID8gbnVtYmVycy5tYXAoTnVtYmVyKSA6IFtdO1xufVxuLyoqXG4gKiBwYXJzZSBhbiBzdmcgcGF0aCBkYXRhIHN0cmluZy4gR2VuZXJhdGVzIGFuIEFycmF5XG4gKiBvZiBjb21tYW5kcyB3aGVyZSBlYWNoIGNvbW1hbmQgaXMgYW4gQXJyYXkgb2YgdGhlXG4gKiBmb3JtIGBbY29tbWFuZCwgYXJnMSwgYXJnMiwgLi4uXWBcbiAqXG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjUGF0aERhdGFHZW5lcmFsSW5mb3JtYXRpb25cbiAqIEBpZ25vcmVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHJldHVybnMge2FycmF5fVxuICovXG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICAgIHZhciBkYXRhID0gW107XG4gICAgdmFyIHAgPSBTdHJpbmcocGF0aCkudHJpbSgpO1xuICAgIC8vIEEgcGF0aCBkYXRhIHNlZ21lbnQgKGlmIHRoZXJlIGlzIG9uZSkgbXVzdCBiZWdpbiB3aXRoIGEgXCJtb3ZldG9cIiBjb21tYW5kXG4gICAgaWYgKHBbMF0gIT09IFwiTVwiICYmIHBbMF0gIT09IFwibVwiKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBwLnJlcGxhY2UoU0VHTUVOVF9QQVRURVJOLCBmdW5jdGlvbiAoXywgY29tbWFuZCwgYXJncykge1xuICAgICAgICB2YXIgdGhlQXJncyA9IHBhcnNlVmFsdWVzKGFyZ3MpO1xuICAgICAgICB2YXIgdHlwZSA9IGNvbW1hbmQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIHRoZUNvbW1hbmQgPSBjb21tYW5kO1xuICAgICAgICAvLyBvdmVybG9hZGVkIG1vdmVUb1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJtXCIgJiYgdGhlQXJncy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBkYXRhLnB1c2goX19zcHJlYWRBcnJheShbdGhlQ29tbWFuZF0sIHRoZUFyZ3Muc3BsaWNlKDAsIDIpLCB0cnVlKSk7XG4gICAgICAgICAgICB0eXBlID0gXCJsXCI7XG4gICAgICAgICAgICB0aGVDb21tYW5kID0gdGhlQ29tbWFuZCA9PT0gXCJtXCIgPyBcImxcIiA6IFwiTFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIElnbm9yZSBpbnZhbGlkIGNvbW1hbmRzXG4gICAgICAgIGlmICh0aGVBcmdzLmxlbmd0aCA8IEFSR19MRU5HVEhbdHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEucHVzaChfX3NwcmVhZEFycmF5KFt0aGVDb21tYW5kXSwgdGhlQXJncy5zcGxpY2UoMCwgQVJHX0xFTkdUSFt0eXBlXSksIHRydWUpKTtcbiAgICAgICAgLy8gVGhlIGNvbW1hbmQgbGV0dGVyIGNhbiBiZSBlbGltaW5hdGVkIG9uIHN1YnNlcXVlbnQgY29tbWFuZHMgaWYgdGhlXG4gICAgICAgIC8vIHNhbWUgY29tbWFuZCBpcyB1c2VkIG11bHRpcGxlIHRpbWVzIGluIGEgcm93IChlLmcuLCB5b3UgY2FuIGRyb3AgdGhlXG4gICAgICAgIC8vIHNlY29uZCBcIkxcIiBpbiBcIk0gMTAwIDIwMCBMIDIwMCAxMDAgTCAtMTAwIC0yMDBcIiBhbmQgdXNlXG4gICAgICAgIC8vIFwiTSAxMDAgMjAwIEwgMjAwIDEwMCAtMTAwIC0yMDBcIiBpbnN0ZWFkKS5cbiAgICAgICAgd2hpbGUgKHRoZUFyZ3MubGVuZ3RoID49IEFSR19MRU5HVEhbdHlwZV0gJiYgdGhlQXJncy5sZW5ndGggJiYgQVJHX0xFTkdUSFt0eXBlXSkge1xuICAgICAgICAgICAgZGF0YS5wdXNoKF9fc3ByZWFkQXJyYXkoW3RoZUNvbW1hbmRdLCB0aGVBcmdzLnNwbGljZSgwLCBBUkdfTEVOR1RIW3R5cGVdKSwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiByb3RhdGVQb2ludChwb2ludCwgYW5nbGUpIHtcbiAgICB2YXIgbnggPSBwb2ludC54ICogTWF0aC5jb3MoYW5nbGUpIC0gcG9pbnQueSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICB2YXIgbnkgPSBwb2ludC55ICogTWF0aC5jb3MoYW5nbGUpICsgcG9pbnQueCAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICBwb2ludC54ID0gbng7XG4gICAgcG9pbnQueSA9IG55O1xufVxuZnVuY3Rpb24gdHJhbnNsYXRlUG9pbnQocG9pbnQsIGR4LCBkeSkge1xuICAgIHBvaW50LnggKz0gZHg7XG4gICAgcG9pbnQueSArPSBkeTtcbn1cbmZ1bmN0aW9uIHNjYWxlUG9pbnQocG9pbnQsIHMpIHtcbiAgICBwb2ludC54ICo9IHM7XG4gICAgcG9pbnQueSAqPSBzO1xufVxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgYnJvd3NlcidzIFBhdGgyRCBhcGlcbiAqL1xudmFyIFBhdGgyRCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXRoMkQocGF0aCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICAgICAgaWYgKHBhdGggJiYgcGF0aCBpbnN0YW5jZW9mIFBhdGgyRCkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5jb21tYW5kcykucHVzaC5hcHBseShfYSwgcGF0aC5jb21tYW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGF0aCkge1xuICAgICAgICAgICAgdGhpcy5jb21tYW5kcyA9IHBhcnNlUGF0aChwYXRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQYXRoMkQucHJvdG90eXBlLmFkZFBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChwYXRoICYmIHBhdGggaW5zdGFuY2VvZiBQYXRoMkQpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuY29tbWFuZHMpLnB1c2guYXBwbHkoX2EsIHBhdGguY29tbWFuZHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQYXRoMkQucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHRoaXMuY29tbWFuZHMucHVzaChbXCJNXCIsIHgsIHldKTtcbiAgICB9O1xuICAgIFBhdGgyRC5wcm90b3R5cGUubGluZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKFtcIkxcIiwgeCwgeV0pO1xuICAgIH07XG4gICAgUGF0aDJELnByb3RvdHlwZS5hcmMgPSBmdW5jdGlvbiAoeCwgeSwgciwgc3RhcnQsIGVuZCwgY2N3KSB7XG4gICAgICAgIHRoaXMuY29tbWFuZHMucHVzaChbXCJBQ1wiLCB4LCB5LCByLCBzdGFydCwgZW5kLCAhIWNjd10pO1xuICAgIH07XG4gICAgUGF0aDJELnByb3RvdHlwZS5hcmNUbyA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Miwgcikge1xuICAgICAgICB0aGlzLmNvbW1hbmRzLnB1c2goW1wiQVRcIiwgeDEsIHkxLCB4MiwgeTIsIHJdKTtcbiAgICB9O1xuICAgIFBhdGgyRC5wcm90b3R5cGUuZWxsaXBzZSA9IGZ1bmN0aW9uICh4LCB5LCByeCwgcnksIGFuZ2xlLCBzdGFydCwgZW5kLCBjY3cpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKFtcIkVcIiwgeCwgeSwgcngsIHJ5LCBhbmdsZSwgc3RhcnQsIGVuZCwgISFjY3ddKTtcbiAgICB9O1xuICAgIFBhdGgyRC5wcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbW1hbmRzLnB1c2goW1wiWlwiXSk7XG4gICAgfTtcbiAgICBQYXRoMkQucHJvdG90eXBlLmJlemllckN1cnZlVG8gPSBmdW5jdGlvbiAoY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSkge1xuICAgICAgICB0aGlzLmNvbW1hbmRzLnB1c2goW1wiQ1wiLCBjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5XSk7XG4gICAgfTtcbiAgICBQYXRoMkQucHJvdG90eXBlLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbiAoY3B4LCBjcHksIHgsIHkpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKFtcIlFcIiwgY3B4LCBjcHksIHgsIHldKTtcbiAgICB9O1xuICAgIFBhdGgyRC5wcm90b3R5cGUucmVjdCA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY29tbWFuZHMucHVzaChbXCJSXCIsIHgsIHksIHdpZHRoLCBoZWlnaHRdKTtcbiAgICB9O1xuICAgIFBhdGgyRC5wcm90b3R5cGUucm91bmRSZWN0ID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGlpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmFkaWkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZHMucHVzaChbXCJSUlwiLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRzLnB1c2goW1wiUlJcIiwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaWldKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFBhdGgyRDtcbn0oKSk7XG5mdW5jdGlvbiBidWlsZFBhdGgoY3R4LCBjb21tYW5kcykge1xuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeSA9IDA7XG4gICAgdmFyIGVuZEFuZ2xlO1xuICAgIHZhciBzdGFydEFuZ2xlO1xuICAgIHZhciBsYXJnZUFyY0ZsYWc7XG4gICAgdmFyIHN3ZWVwRmxhZztcbiAgICB2YXIgZW5kUG9pbnQ7XG4gICAgdmFyIG1pZFBvaW50O1xuICAgIHZhciBhbmdsZTtcbiAgICB2YXIgbGFtYmRhO1xuICAgIHZhciB0MTtcbiAgICB2YXIgdDI7XG4gICAgdmFyIHgxO1xuICAgIHZhciB5MTtcbiAgICB2YXIgcjtcbiAgICB2YXIgcng7XG4gICAgdmFyIHJ5O1xuICAgIHZhciB3O1xuICAgIHZhciBoO1xuICAgIHZhciBwYXRoVHlwZTtcbiAgICB2YXIgY2VudGVyUG9pbnQ7XG4gICAgdmFyIGNjdztcbiAgICB2YXIgcmFkaWk7XG4gICAgdmFyIGNweCA9IG51bGw7XG4gICAgdmFyIGNweSA9IG51bGw7XG4gICAgdmFyIHFjcHggPSBudWxsO1xuICAgIHZhciBxY3B5ID0gbnVsbDtcbiAgICB2YXIgc3RhcnRQb2ludCA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRQb2ludCA9IG51bGw7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcGF0aFR5cGUgPSBjb21tYW5kc1tpXVswXTtcbiAgICAgICAgLy8gUmVzZXQgY29udHJvbCBwb2ludCBpZiBjb21tYW5kIGlzIG5vdCBjdWJpY1xuICAgICAgICBpZiAocGF0aFR5cGUgIT09IFwiU1wiICYmIHBhdGhUeXBlICE9PSBcInNcIiAmJiBwYXRoVHlwZSAhPT0gXCJDXCIgJiYgcGF0aFR5cGUgIT09IFwiY1wiKSB7XG4gICAgICAgICAgICBjcHggPSBudWxsO1xuICAgICAgICAgICAgY3B5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aFR5cGUgIT09IFwiVFwiICYmIHBhdGhUeXBlICE9PSBcInRcIiAmJiBwYXRoVHlwZSAhPT0gXCJRXCIgJiYgcGF0aFR5cGUgIT09IFwicVwiKSB7XG4gICAgICAgICAgICBxY3B4ID0gbnVsbDtcbiAgICAgICAgICAgIHFjcHkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjID0gdm9pZCAwO1xuICAgICAgICBzd2l0Y2ggKHBhdGhUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgICAgICBjID0gY29tbWFuZHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBhdGhUeXBlID09PSBcIm1cIikge1xuICAgICAgICAgICAgICAgICAgICB4ICs9IGNbMV07XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gY1syXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjWzFdO1xuICAgICAgICAgICAgICAgICAgICB5ID0gY1syXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhdGhUeXBlID09PSBcIk1cIiB8fCAhc3RhcnRQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFBvaW50ID0geyB4OiB4LCB5OiB5IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibFwiOlxuICAgICAgICAgICAgICAgIGMgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgICAgICB4ICs9IGNbMV07XG4gICAgICAgICAgICAgICAgeSArPSBjWzJdO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTFwiOlxuICAgICAgICAgICAgICAgIGMgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgICAgICB4ID0gY1sxXTtcbiAgICAgICAgICAgICAgICB5ID0gY1syXTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgICBjID0gY29tbWFuZHNbaV07XG4gICAgICAgICAgICAgICAgeCA9IGNbMV07XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICAgICAgYyA9IGNvbW1hbmRzW2ldO1xuICAgICAgICAgICAgICAgIHggKz0gY1sxXTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlZcIjpcbiAgICAgICAgICAgICAgICBjID0gY29tbWFuZHNbaV07XG4gICAgICAgICAgICAgICAgeSA9IGNbMV07XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ2XCI6XG4gICAgICAgICAgICAgICAgYyA9IGNvbW1hbmRzW2ldO1xuICAgICAgICAgICAgICAgIHkgKz0gY1sxXTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJBXCI6XG4gICAgICAgICAgICAgICAgYyA9IGNvbW1hbmRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UG9pbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGF0aFR5cGUgPT09IFwiYVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gY1s2XTtcbiAgICAgICAgICAgICAgICAgICAgeSArPSBjWzddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGNbNl07XG4gICAgICAgICAgICAgICAgICAgIHkgPSBjWzddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByeCA9IGNbMV07IC8vIHJ4XG4gICAgICAgICAgICAgICAgcnkgPSBjWzJdOyAvLyByeVxuICAgICAgICAgICAgICAgIGFuZ2xlID0gKGNbM10gKiBNYXRoLlBJKSAvIDE4MDtcbiAgICAgICAgICAgICAgICBsYXJnZUFyY0ZsYWcgPSAhIWNbNF07XG4gICAgICAgICAgICAgICAgc3dlZXBGbGFnID0gISFjWzVdO1xuICAgICAgICAgICAgICAgIGVuZFBvaW50ID0geyB4OiB4LCB5OiB5IH07XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRy9pbXBsbm90ZS5odG1sI0FyY0ltcGxlbWVudGF0aW9uTm90ZXNcbiAgICAgICAgICAgICAgICBtaWRQb2ludCA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogKGN1cnJlbnRQb2ludC54IC0gZW5kUG9pbnQueCkgLyAyLFxuICAgICAgICAgICAgICAgICAgICB5OiAoY3VycmVudFBvaW50LnkgLSBlbmRQb2ludC55KSAvIDJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJvdGF0ZVBvaW50KG1pZFBvaW50LCAtYW5nbGUpO1xuICAgICAgICAgICAgICAgIC8vIHJhZGl1cyBjb3JyZWN0aW9uXG4gICAgICAgICAgICAgICAgbGFtYmRhID0gKG1pZFBvaW50LnggKiBtaWRQb2ludC54KSAvIChyeCAqIHJ4KSArIChtaWRQb2ludC55ICogbWlkUG9pbnQueSkgLyAocnkgKiByeSk7XG4gICAgICAgICAgICAgICAgaWYgKGxhbWJkYSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFtYmRhID0gTWF0aC5zcXJ0KGxhbWJkYSk7XG4gICAgICAgICAgICAgICAgICAgIHJ4ICo9IGxhbWJkYTtcbiAgICAgICAgICAgICAgICAgICAgcnkgKj0gbGFtYmRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjZW50ZXJQb2ludCA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogKHJ4ICogbWlkUG9pbnQueSkgLyByeSxcbiAgICAgICAgICAgICAgICAgICAgeTogLShyeSAqIG1pZFBvaW50LngpIC8gcnhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHQxID0gcnggKiByeCAqIHJ5ICogcnk7XG4gICAgICAgICAgICAgICAgdDIgPSByeCAqIHJ4ICogbWlkUG9pbnQueSAqIG1pZFBvaW50LnkgKyByeSAqIHJ5ICogbWlkUG9pbnQueCAqIG1pZFBvaW50Lng7XG4gICAgICAgICAgICAgICAgaWYgKHN3ZWVwRmxhZyAhPT0gbGFyZ2VBcmNGbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlUG9pbnQoY2VudGVyUG9pbnQsIE1hdGguc3FydCgodDEgLSB0MikgLyB0MikgfHwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzY2FsZVBvaW50KGNlbnRlclBvaW50LCAtTWF0aC5zcXJ0KCh0MSAtIHQyKSAvIHQyKSB8fCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhcnRBbmdsZSA9IE1hdGguYXRhbjIoKG1pZFBvaW50LnkgLSBjZW50ZXJQb2ludC55KSAvIHJ5LCAobWlkUG9pbnQueCAtIGNlbnRlclBvaW50LngpIC8gcngpO1xuICAgICAgICAgICAgICAgIGVuZEFuZ2xlID0gTWF0aC5hdGFuMigtKG1pZFBvaW50LnkgKyBjZW50ZXJQb2ludC55KSAvIHJ5LCAtKG1pZFBvaW50LnggKyBjZW50ZXJQb2ludC54KSAvIHJ4KTtcbiAgICAgICAgICAgICAgICByb3RhdGVQb2ludChjZW50ZXJQb2ludCwgYW5nbGUpO1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVBvaW50KGNlbnRlclBvaW50LCAoZW5kUG9pbnQueCArIGN1cnJlbnRQb2ludC54KSAvIDIsIChlbmRQb2ludC55ICsgY3VycmVudFBvaW50LnkpIC8gMik7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGNlbnRlclBvaW50LngsIGNlbnRlclBvaW50LnkpO1xuICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoYW5nbGUpO1xuICAgICAgICAgICAgICAgIGN0eC5zY2FsZShyeCwgcnkpO1xuICAgICAgICAgICAgICAgIGN0eC5hcmMoMCwgMCwgMSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsICFzd2VlcEZsYWcpO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQ1wiOlxuICAgICAgICAgICAgICAgIGMgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgICAgICBjcHggPSBjWzNdOyAvLyBMYXN0IGNvbnRyb2wgcG9pbnRcbiAgICAgICAgICAgICAgICBjcHkgPSBjWzRdO1xuICAgICAgICAgICAgICAgIHggPSBjWzVdO1xuICAgICAgICAgICAgICAgIHkgPSBjWzZdO1xuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNbMV0sIGNbMl0sIGNweCwgY3B5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgICAgICAgYyA9IGNvbW1hbmRzW2ldO1xuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNbMV0gKyB4LCBjWzJdICsgeSwgY1szXSArIHgsIGNbNF0gKyB5LCBjWzVdICsgeCwgY1s2XSArIHkpO1xuICAgICAgICAgICAgICAgIGNweCA9IGNbM10gKyB4OyAvLyBMYXN0IGNvbnRyb2wgcG9pbnRcbiAgICAgICAgICAgICAgICBjcHkgPSBjWzRdICsgeTtcbiAgICAgICAgICAgICAgICB4ICs9IGNbNV07XG4gICAgICAgICAgICAgICAgeSArPSBjWzZdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgICAgICBjID0gY29tbWFuZHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNweCA9PT0gbnVsbCB8fCBjcHkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3B4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgY3B5ID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oMiAqIHggLSBjcHgsIDIgKiB5IC0gY3B5LCBjWzFdLCBjWzJdLCBjWzNdLCBjWzRdKTtcbiAgICAgICAgICAgICAgICBjcHggPSBjWzFdOyAvLyBsYXN0IGNvbnRyb2wgcG9pbnRcbiAgICAgICAgICAgICAgICBjcHkgPSBjWzJdO1xuICAgICAgICAgICAgICAgIHggPSBjWzNdO1xuICAgICAgICAgICAgICAgIHkgPSBjWzRdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgICAgICBjID0gY29tbWFuZHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNweCA9PT0gbnVsbCB8fCBjcHkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3B4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgY3B5ID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oMiAqIHggLSBjcHgsIDIgKiB5IC0gY3B5LCBjWzFdICsgeCwgY1syXSArIHksIGNbM10gKyB4LCBjWzRdICsgeSk7XG4gICAgICAgICAgICAgICAgY3B4ID0gY1sxXSArIHg7IC8vIGxhc3QgY29udHJvbCBwb2ludFxuICAgICAgICAgICAgICAgIGNweSA9IGNbMl0gKyB5O1xuICAgICAgICAgICAgICAgIHggKz0gY1szXTtcbiAgICAgICAgICAgICAgICB5ICs9IGNbNF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUVwiOlxuICAgICAgICAgICAgICAgIGMgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgICAgICBxY3B4ID0gY1sxXTsgLy8gbGFzdCBjb250cm9sIHBvaW50XG4gICAgICAgICAgICAgICAgcWNweSA9IGNbMl07XG4gICAgICAgICAgICAgICAgeCA9IGNbM107XG4gICAgICAgICAgICAgICAgeSA9IGNbNF07XG4gICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8ocWNweCwgcWNweSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicVwiOlxuICAgICAgICAgICAgICAgIGMgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgICAgICBxY3B4ID0gY1sxXSArIHg7IC8vIGxhc3QgY29udHJvbCBwb2ludFxuICAgICAgICAgICAgICAgIHFjcHkgPSBjWzJdICsgeTtcbiAgICAgICAgICAgICAgICB4ICs9IGNbM107XG4gICAgICAgICAgICAgICAgeSArPSBjWzRdO1xuICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHFjcHgsIHFjcHksIHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlRcIjpcbiAgICAgICAgICAgICAgICBjID0gY29tbWFuZHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHFjcHggPT09IG51bGwgfHwgcWNweSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBxY3B4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgcWNweSA9IHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHFjcHggPSAyICogeCAtIHFjcHg7IC8vIGxhc3QgY29udHJvbCBwb2ludFxuICAgICAgICAgICAgICAgIHFjcHkgPSAyICogeSAtIHFjcHk7XG4gICAgICAgICAgICAgICAgeCA9IGNbMV07XG4gICAgICAgICAgICAgICAgeSA9IGNbMl07XG4gICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8ocWNweCwgcWNweSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidFwiOlxuICAgICAgICAgICAgICAgIGMgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocWNweCA9PT0gbnVsbCB8fCBxY3B5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHFjcHggPSB4O1xuICAgICAgICAgICAgICAgICAgICBxY3B5ID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcWNweCA9IDIgKiB4IC0gcWNweDsgLy8gbGFzdCBjb250cm9sIHBvaW50XG4gICAgICAgICAgICAgICAgcWNweSA9IDIgKiB5IC0gcWNweTtcbiAgICAgICAgICAgICAgICB4ICs9IGNbMV07XG4gICAgICAgICAgICAgICAgeSArPSBjWzJdO1xuICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHFjcHgsIHFjcHksIHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInpcIjpcbiAgICAgICAgICAgIGNhc2UgXCJaXCI6XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0UG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHN0YXJ0UG9pbnQueDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHN0YXJ0UG9pbnQueTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhcnRQb2ludCA9IG51bGw7XG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkFDXCI6IC8vIGFyY1xuICAgICAgICAgICAgICAgIGMgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgICAgICB4ID0gY1sxXTtcbiAgICAgICAgICAgICAgICB5ID0gY1syXTtcbiAgICAgICAgICAgICAgICByID0gY1szXTtcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlID0gY1s0XTtcbiAgICAgICAgICAgICAgICBlbmRBbmdsZSA9IGNbNV07XG4gICAgICAgICAgICAgICAgY2N3ID0gY1s2XTtcbiAgICAgICAgICAgICAgICBjdHguYXJjKHgsIHksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjY3cpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkFUXCI6IC8vIGFyY1RvXG4gICAgICAgICAgICAgICAgYyA9IGNvbW1hbmRzW2ldO1xuICAgICAgICAgICAgICAgIHgxID0gY1sxXTtcbiAgICAgICAgICAgICAgICB5MSA9IGNbMl07XG4gICAgICAgICAgICAgICAgeCA9IGNbM107XG4gICAgICAgICAgICAgICAgeSA9IGNbNF07XG4gICAgICAgICAgICAgICAgciA9IGNbNV07XG4gICAgICAgICAgICAgICAgY3R4LmFyY1RvKHgxLCB5MSwgeCwgeSwgcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRVwiOiAvLyBlbGxpcHNlXG4gICAgICAgICAgICAgICAgYyA9IGNvbW1hbmRzW2ldO1xuICAgICAgICAgICAgICAgIHggPSBjWzFdO1xuICAgICAgICAgICAgICAgIHkgPSBjWzJdO1xuICAgICAgICAgICAgICAgIHJ4ID0gY1szXTtcbiAgICAgICAgICAgICAgICByeSA9IGNbNF07XG4gICAgICAgICAgICAgICAgYW5nbGUgPSBjWzVdO1xuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBjWzZdO1xuICAgICAgICAgICAgICAgIGVuZEFuZ2xlID0gY1s3XTtcbiAgICAgICAgICAgICAgICBjY3cgPSBjWzhdO1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUocngsIHJ5KTtcbiAgICAgICAgICAgICAgICBjdHguYXJjKDAsIDAsIDEsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjY3cpO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUlwiOiAvLyByZWN0XG4gICAgICAgICAgICAgICAgYyA9IGNvbW1hbmRzW2ldO1xuICAgICAgICAgICAgICAgIHggPSBjWzFdO1xuICAgICAgICAgICAgICAgIHkgPSBjWzJdO1xuICAgICAgICAgICAgICAgIHcgPSBjWzNdO1xuICAgICAgICAgICAgICAgIGggPSBjWzRdO1xuICAgICAgICAgICAgICAgIHN0YXJ0UG9pbnQgPSB7IHg6IHgsIHk6IHkgfTtcbiAgICAgICAgICAgICAgICBjdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJSUlwiOiAvLyByb3VuZGVkUmVjdFxuICAgICAgICAgICAgICAgIGMgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgICAgICB4ID0gY1sxXTtcbiAgICAgICAgICAgICAgICB5ID0gY1syXTtcbiAgICAgICAgICAgICAgICB3ID0gY1szXTtcbiAgICAgICAgICAgICAgICBoID0gY1s0XTtcbiAgICAgICAgICAgICAgICByYWRpaSA9IGNbNV07XG4gICAgICAgICAgICAgICAgc3RhcnRQb2ludCA9IHsgeDogeCwgeTogeSB9O1xuICAgICAgICAgICAgICAgIGN0eC5yb3VuZFJlY3QoeCwgeSwgdywgaCwgcmFkaWkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3VycmVudFBvaW50KSB7XG4gICAgICAgICAgICBjdXJyZW50UG9pbnQgPSB7IHg6IHgsIHk6IHkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludC54ID0geDtcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludC55ID0geTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUG9seWZpbGxzIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCBzdHJva2UsIGZpbGwgYW5kIGlzUG9pbnRJblBhdGggc28gdGhhdCB0aGV5IHN1cHBvcnQgUGF0aDJEIG9iamVjdHMuXG4gKiBAcGFyYW0ge1dpbmRvd0xpa2V9IHdpbmRvdyAtIHdpbmRvdyBsaWtlIG9iamVjdCBjb250YWluaW5nIGEgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIHBvbHlmaWxsUGF0aDJEKHdpbmRvdykge1xuICAgIGlmICghd2luZG93IHx8ICF3aW5kb3cuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHx8IHdpbmRvdy5QYXRoMkQpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gd2luZG93LkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2QgKi9cbiAgICAvLyBzZXR0aW5nIHVuYm91bmQgZnVuY3Rpb25zIGhlcmUuIE1ha2Ugc3VyZSB0aGlzIGlzIHNldCBpbiBmdW5jdGlvbiBjYWxsIGxhdGVyXG4gICAgdmFyIGNGaWxsID0gQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5maWxsO1xuICAgIHZhciBjU3Ryb2tlID0gQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5zdHJva2U7XG4gICAgdmFyIGNJc1BvaW50SW5QYXRoID0gQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5pc1BvaW50SW5QYXRoO1xuICAgIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kICovXG4gICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJnc1swXSBpbnN0YW5jZW9mIFBhdGgyRCkge1xuICAgICAgICAgICAgdmFyIHBhdGggPSBhcmdzWzBdO1xuICAgICAgICAgICAgdmFyIGZpbGxSdWxlID0gYXJnc1sxXSB8fCBcIm5vbnplcm9cIjtcbiAgICAgICAgICAgIGJ1aWxkUGF0aCh0aGlzLCBwYXRoLmNvbW1hbmRzKTtcbiAgICAgICAgICAgIGNGaWxsLmFwcGx5KHRoaXMsIFtmaWxsUnVsZV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZpbGxSdWxlID0gYXJnc1swXSB8fCBcIm5vbnplcm9cIjtcbiAgICAgICAgICAgIHJldHVybiBjRmlsbC5hcHBseSh0aGlzLCBbZmlsbFJ1bGVdKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5zdHJva2UgPSBmdW5jdGlvbiBzdHJva2UocGF0aCkge1xuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgYnVpbGRQYXRoKHRoaXMsIHBhdGguY29tbWFuZHMpO1xuICAgICAgICB9XG4gICAgICAgIGNTdHJva2UuYXBwbHkodGhpcyk7XG4gICAgfTtcbiAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmlzUG9pbnRJblBhdGggPSBmdW5jdGlvbiBpc1BvaW50SW5QYXRoKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgUGF0aDJEKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCBhcmd1bWVudCBpcyBhIFBhdGgyRCBvYmplY3RcbiAgICAgICAgICAgIHZhciBwYXRoID0gYXJnc1swXTtcbiAgICAgICAgICAgIHZhciB4ID0gYXJnc1sxXTtcbiAgICAgICAgICAgIHZhciB5ID0gYXJnc1syXTtcbiAgICAgICAgICAgIHZhciBmaWxsUnVsZSA9IGFyZ3NbM10gfHwgXCJub256ZXJvXCI7XG4gICAgICAgICAgICBidWlsZFBhdGgodGhpcywgcGF0aC5jb21tYW5kcyk7XG4gICAgICAgICAgICByZXR1cm4gY0lzUG9pbnRJblBhdGguYXBwbHkodGhpcywgW3gsIHksIGZpbGxSdWxlXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY0lzUG9pbnRJblBhdGguYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5QYXRoMkQgPSBQYXRoMkQ7XG59XG5cbmZ1bmN0aW9uIHJvdW5kUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpaSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHJhZGlpID09PSB2b2lkIDApIHsgcmFkaWkgPSAwOyB9XG4gICAgaWYgKHR5cGVvZiByYWRpaSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgcmFkaWkgPSBbcmFkaWldO1xuICAgIH1cbiAgICAvLyBjaGVjayBmb3IgcmFuZ2UgZXJyb3JcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyYWRpaSkpIHtcbiAgICAgICAgaWYgKHJhZGlpLmxlbmd0aCA9PT0gMCB8fCByYWRpaS5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICdyb3VuZFJlY3QnIG9uICdcIi5jb25jYXQodGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCBcIic6IFwiKS5jb25jYXQocmFkaWkubGVuZ3RoLCBcIiByYWRpaSBwcm92aWRlZC4gQmV0d2VlbiBvbmUgYW5kIGZvdXIgcmFkaWkgYXJlIG5lY2Vzc2FyeS5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHJhZGlpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlmICh2IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ3JvdW5kUmVjdCcgb24gJ1wiLmNvbmNhdChfdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCBcIic6IFJhZGl1cyB2YWx1ZSBcIikuY29uY2F0KHYsIFwiIGlzIG5lZ2F0aXZlLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocmFkaWkubGVuZ3RoID09PSAxICYmIHJhZGlpWzBdID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIC8vIHNldCB0aGUgY29ybmVyc1xuICAgIC8vIHRsID0gdG9wIGxlZnQgcmFkaXVzXG4gICAgLy8gdHIgPSB0b3AgcmlnaHQgcmFkaXVzXG4gICAgLy8gYnIgPSBib3R0b20gcmlnaHQgcmFkaXVzXG4gICAgLy8gYmwgPSBib3R0b20gbGVmdCByYWRpdXNcbiAgICB2YXIgbWluUmFkaXVzID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyO1xuICAgIHZhciB0ciwgYnIsIGJsO1xuICAgIHZhciB0bCA9ICh0ciA9IGJyID0gYmwgPSBNYXRoLm1pbihtaW5SYWRpdXMsIHJhZGlpWzBdKSk7XG4gICAgaWYgKHJhZGlpLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0ciA9IGJsID0gTWF0aC5taW4obWluUmFkaXVzLCByYWRpaVsxXSk7XG4gICAgfVxuICAgIGlmIChyYWRpaS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgdHIgPSBibCA9IE1hdGgubWluKG1pblJhZGl1cywgcmFkaWlbMV0pO1xuICAgICAgICBiciA9IE1hdGgubWluKG1pblJhZGl1cywgcmFkaWlbMl0pO1xuICAgIH1cbiAgICBpZiAocmFkaWkubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHRyID0gTWF0aC5taW4obWluUmFkaXVzLCByYWRpaVsxXSk7XG4gICAgICAgIGJyID0gTWF0aC5taW4obWluUmFkaXVzLCByYWRpaVsyXSk7XG4gICAgICAgIGJsID0gTWF0aC5taW4obWluUmFkaXVzLCByYWRpaVszXSk7XG4gICAgfVxuICAgIC8vIGJlZ2luIHdpdGggY2xvc2luZyBjdXJyZW50IHBhdGhcbiAgICAvLyB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIC8vIGxldCdzIGRyYXcgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlXG4gICAgdGhpcy5tb3ZlVG8oeCwgeSArIGhlaWdodCAtIGJsKTtcbiAgICB0aGlzLmFyY1RvKHgsIHksIHggKyB0bCwgeSwgdGwpO1xuICAgIHRoaXMuYXJjVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyB0ciwgdHIpO1xuICAgIHRoaXMuYXJjVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSBiciwgeSArIGhlaWdodCwgYnIpO1xuICAgIHRoaXMuYXJjVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIGJsLCBibCk7XG4gICAgLy8gYW5kIG1vdmUgdG8gcmVjdHMgY29udHJvbCBwb2ludCBmb3IgZnVydGhlciBwYXRoIGRyYXdpbmdcbiAgICB0aGlzLm1vdmVUbyh4LCB5KTtcbn1cbi8qKlxuICogUG9seWZpbGxzIHJvdW5kUmVjdCBvbiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgYW5kIFBhdGgyRFxuICogQHBhcmFtIHtXaW5kb3dMaWtlfSB3aW5kb3cgLSB3aW5kb3cgbGlrZSBvYmplY3QgY29udGFpbmluZyBib3RoIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCBhbmQgUGF0aDJEIGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIHBvbHlmaWxsUm91bmRSZWN0KHdpbmRvdykge1xuICAgIGlmICghd2luZG93IHx8ICF3aW5kb3cuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IHdpbmRvdy5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIFBhdGgyRCA9IHdpbmRvdy5QYXRoMkQ7XG4gICAgLy8gcG9seWZpbGwgdW5zdXBwb3J0ZWQgcm91bmRSZWN0IGZvciBlLmcuIGZpcmVmb3ggaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9yb3VuZFJlY3QjYnJvd3Nlcl9jb21wYXRpYmlsaXR5XG4gICAgaWYgKENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCAmJiAhQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5yb3VuZFJlY3QpIHtcbiAgICAgICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5yb3VuZFJlY3QgPSByb3VuZFJlY3Q7XG4gICAgfVxuICAgIGlmIChQYXRoMkQgJiYgIVBhdGgyRC5wcm90b3R5cGUucm91bmRSZWN0KSB7XG4gICAgICAgIFBhdGgyRC5wcm90b3R5cGUucm91bmRSZWN0ID0gcm91bmRSZWN0O1xuICAgIH1cbn1cblxuZXhwb3J0cy5QYXRoMkQgPSBQYXRoMkQ7XG5leHBvcnRzLnBhcnNlUGF0aCA9IHBhcnNlUGF0aDtcbmV4cG9ydHMucG9seWZpbGxQYXRoMkQgPSBwb2x5ZmlsbFBhdGgyRDtcbmV4cG9ydHMucG9seWZpbGxSb3VuZFJlY3QgPSBwb2x5ZmlsbFJvdW5kUmVjdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/path2d-polyfill/dist/path2d-node.cjs\n");

/***/ })

};
;